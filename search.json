[{"title":"为什么在8086处理器不能直接把立即数存入段寄存器？","url":"/2022/01Why-can-t-we-move-an-immediate-operand-to-an-ES-register-in-8086/","content":"<blockquote>\n<p>为什么在8086处理器不能直接把立即数存入段寄存器？<br>Why can’t we move an immediate operand to an ES register in 8086?  </p>\n</blockquote>\n<h1 id=\"向段寄存器存内容的常见两步\"><a href=\"#向段寄存器存内容的常见两步\" class=\"headerlink\" title=\"向段寄存器存内容的常见两步\"></a>向段寄存器存内容的常见两步</h1><p>如果有一个段地址，需要存入段寄存器（ES），在 8086 处理器中，通常要这样做：  </p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">mov ax, 0xb800;显存地址</span><br><span class=\"line\">mov es, ax</span><br></pre></td></tr></table></figure>\n<p>不能直接向 ES 直接传入立即数，必须先存入通用寄存器（如 ax），再从 ax 存入 ES。<br>根据 Quora 上 Paul 的<a href=\"https://qr.ae/pG3Ly5\">回答</a>,8086 确实是没有设计这样的指令：</p>\n<blockquote>\n<p>The designers of the 8086 architecture didn’t consider being able to store an immediate into any segment register important enough to encode it as an instruction in the binary format. As such, you need to do this in two steps: load the immediate into ax and then store it into the segment register.<br>译：8086 架构的设计者没有考虑能够将立即数存储到任何重要的段寄存器中，以将其编码为二进制格式的指令。因此，您需要分两步执行此操作：将立即数加载到 ax 中，然后将其存储到段寄存器中。  </p>\n</blockquote>\n<h1 id=\"两种可能：\"><a href=\"#两种可能：\" class=\"headerlink\" title=\"两种可能：\"></a>两种可能：</h1><h2 id=\"8086-时代不允许这复杂的设计了：\"><a href=\"#8086-时代不允许这复杂的设计了：\" class=\"headerlink\" title=\"8086 时代不允许这复杂的设计了：\"></a>8086 时代不允许这复杂的设计了：</h2><p>北极在知乎上的<a href=\"https://www.zhihu.com/question/43608287/answer/96163327\">回答</a>:  </p>\n<blockquote>\n<p>我个人觉得，就是编码太麻烦，opcode不太够用，指令太长。<br>……<br><img src=\"8086%E5%AF%84%E5%AD%98%E5%99%A8%E7%BC%96%E7%A0%81.jpg\"><br>因为MOV操作的寄存器有两个，其中的一个还可能是内存，还可能是寄存器组合，这样的话，2*3bit（注：原文应指8bit）用于描述寄存器，剩下2个bit用于描述是内存还是别的东西，这样算下来，一个字节勉强够用。而如果把段寄存器加上，就需要4个bit编码一个寄存器，仅仅描述两个寄存器就需要一个字节，加上其它的修饰，MOV指令长度就需要整体增加一个字节，这对于过去的计算机来说，开销无疑是非常巨大的，过去计算机内存都是以KB计算的，每个MOV指令增加一个字节，在设计者看来是无法接受的。  </p>\n</blockquote>\n<p>这大概就是在说，为了节省节省开销，没有更多空间留给 <code>mov es imd</code> 形式的指令设计了。<br>这与 Paul 的<a href=\"https://qr.ae/pG3Ly5\">回答</a>中的评论是一致的：  </p>\n<blockquote>\n<p>I don’t think it’s impossible to fit it in, but rather omitting it simplifies the processor design, and those times are different from today in which you add extra complexity for performance.<br>译：我不认为不可能设计并适配它（指<code>mov es imd</code> 形式的指令），而是省略它可以简化处理器的设计，而那个时代与今天这为了性能而增加额外的复杂性的时代不同。  </p>\n</blockquote>\n<h2 id=\"安全性问题：\"><a href=\"#安全性问题：\" class=\"headerlink\" title=\"安全性问题：\"></a>安全性问题：</h2><p>CSDN 上有一个很老的<a href=\"https://bbs.csdn.net/topics/340215235\">帖子</a>，其中有一个回复考虑到了安全性的问题：<br><img src=\"burningstyle%E7%9A%84%E5%9B%9E%E5%A4%8D.jpg\"><br>在 Paul 的<a href=\"https://qr.ae/pG3Ly5\">回答</a>中也有提到：  </p>\n<blockquote>\n<p>Now storing an immediate into a segment register has a second issue — if you’re not the OS, how do you know that that memory region doesn’t belong to someone else?<br>译：现在，将一个即时数据存储到段寄存器中还有一个问题–如果你不是操作系统，你怎么知道那个内存区域不属于其他人？  </p>\n</blockquote>\n<p>其实这个不难理解，汇编程序对内存的使用应当存在一定的抽象以保证安全。  </p>\n"},{"title":"Hello World","url":"/2022/01hello-world/","content":"<p>Welcome to <a href=\"https://hexo.io/\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/server.html\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/one-command-deployment.html\">Deployment</a></p>\n"},{"title":"二进制、数学和计算机","url":"/2022/01binary-and-math/","content":"<p>如果非要有一个开始，我愿意是香农写下“只是用继电器和开关，就能实现对两数自动求和”的那个夜晚。  </p>\n<blockquote>\n<p>使用继电电路进行复杂的数学运算是可能的。事实上，任何可以用如果、或、与等字词在有限步内加以完整描述的操作，都可以用继电器自动完成。</p>\n<p>——香农  </p>\n</blockquote>\n<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>越来越多人学习编程，但是他们并没有理解代码运行的原理。计算机相关专业的人中，相当一部分也不能说出个所以然，只能把计算机看作一个黑匣子，学习编程语言就像是在霍格沃兹学习魔咒。<br>任何事物的出现都是由前因的。计算机也是有它的理论和物质基础的。<br>理解了计算机计算的原理及实现，对于克服学编程的为难心理是很有帮助的。  </p>\n<h1 id=\"进制是可以互相转化的\"><a href=\"#进制是可以互相转化的\" class=\"headerlink\" title=\"进制是可以互相转化的\"></a>进制是可以互相转化的</h1><p>日常使用的十进制，只用个位是没有办法表示出“十”的，“9+1”就需要进位。<br>二进制就是只用个位没有办法表示出“2”，想要表示“1+1”的话，不能写“2”，而要写“10”，为了避免歧义，在书写的时候会在后面加上括起来的二，以示二进制，比如“10(2)”。<br>同理，“10(2)=2(10)”，二进制的“10”等于十进制的“2”。<br>有一天外星人告诉你圆周率约是：11.00100100001111110110100110100010010110110000100101<br>你应该要能换算成：3.1415926<br><strong>不同的进制下，数学运算结果是等价的。</strong><br>所以，要是设计<strong>计算十进制结果</strong>的自动运算机器太麻烦，那么造一台<strong>计算二进制结果</strong>的运算机器，其实效果是一样的。<br>二进制下是如何做计算的呢？  </p>\n<h1 id=\"生活随处可见布尔运算\"><a href=\"#生活随处可见布尔运算\" class=\"headerlink\" title=\"生活随处可见布尔运算\"></a>生活随处可见布尔运算</h1><p>实际上，布尔运算很早就被发明了。<br>布尔是英国的数学家，在1847年发明了处理二值之间关系的逻辑数学计算法，包括联合、相交、相减。<br>与、或、非三种布尔运算，实质上是对二进制输入（真或假、1或0）的某种处理，做单一输出。<br><img src=\"%E7%9C%9F%E5%80%BC%E8%A1%A8.jpg\"><br><img src=\"%E4%B8%8E%E6%88%96%E9%9D%9E%E8%BF%90%E7%AE%97.jpg\"><br>直接在纸面理解，其实也不复杂，但是太<strong>抽象</strong>了。<br>我找到了一个很形象的<a href=\"https://weibo.com/6105753431/Im8wYsdq9\">例子</a>，强烈推荐你去看一下。<br>后来人们又发现,这样的过程（布尔运算），还可以用<a href=\"https://www.bilibili.com/video/BV1zh411f7bv\">电路实现</a>。这样子的电路被叫做逻辑电路。  </p>\n<h1 id=\"从布尔到加法运算\"><a href=\"#从布尔到加法运算\" class=\"headerlink\" title=\"从布尔到加法运算\"></a>从布尔到加法运算</h1><p>光有简单的逻辑电路，什么也做不了，真正让电路在普通人理解层面的解决数学问题，归功于下面这个发现：<br>当你要做一位二进制加法，你把所有的可能都列出来：  </p>\n<blockquote>\n<p>X+Y=Z<br>0+0=0<br>0+1=1<br>1+0=1<br>1+1=10</p>\n</blockquote>\n<p>然后，你总结了一下，得到了下面这张表：  </p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">X</th>\n<th align=\"center\">Y</th>\n<th align=\"center\">进位</th>\n<th align=\"center\">和</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">0</td>\n<td align=\"center\">0</td>\n<td align=\"center\">0</td>\n<td align=\"center\">0</td>\n</tr>\n<tr>\n<td align=\"center\">0</td>\n<td align=\"center\">1</td>\n<td align=\"center\">0</td>\n<td align=\"center\">1</td>\n</tr>\n<tr>\n<td align=\"center\">1</td>\n<td align=\"center\">0</td>\n<td align=\"center\">0</td>\n<td align=\"center\">1</td>\n</tr>\n<tr>\n<td align=\"center\">1</td>\n<td align=\"center\">1</td>\n<td align=\"center\">1</td>\n<td align=\"center\">0</td>\n</tr>\n</tbody></table>\n<p>你会发现，把 X、Y 看作输入，进位的结果，就是“X与Y”的结果，和的结果就是“X异或Y”的结果。<br>自然而然，按照这个思路，你就能用<a href=\"https://www.bilibili.com/video/BV1HZ4y137SY\">电路实现一个加法器</a>，用来做二进制的加法。<br>其余的四则运算也同样能用电路实现。<br>这样子的电路计算出的结果是二进制的，最后再转化成十进制，就是我们日常熟悉的结果形式了。  </p>\n<h1 id=\"其余参考资料\"><a href=\"#其余参考资料\" class=\"headerlink\" title=\"其余参考资料\"></a>其余参考资料</h1><ul>\n<li><a href=\"https://www.zhihu.com/question/20112194/answer/84394468\">为什么计算机能读懂 1 和 0 ？ - 张大昭的回答 - 知乎</a>  </li>\n</ul>\n"}]